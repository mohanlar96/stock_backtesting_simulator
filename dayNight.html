<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intraday Trading Simulator with Caching</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 sm:p-6 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Intraday Trading Simulator</h1>
            <p class="mt-2 text-md text-gray-600">Now with pre-defined trading strategies and data caching!</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-6 max-w-5xl mx-auto">
            <!-- Controls -->
            <div class="flex flex-col sm:flex-row items-start justify-between gap-4 border-b border-gray-200 pb-6">
                <div class="flex-grow space-y-3">
                    <div class="space-y-3 pt-2">
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <!-- Ticker and API Key -->
                            <div class="flex items-center gap-2">
                                <label for="ticker-input" class="font-semibold text-gray-800 whitespace-nowrap">Ticker:</label>
                                <input type="text" id="ticker-input" value="SPY" placeholder="e.g., SPY, QQQ" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full uppercase">
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="api-key" class="font-semibold text-gray-800 whitespace-nowrap">API Key:</label>
                                <input type="password" value="PF9NLS6UHJ5VH89X" id="api-key" placeholder="Get a free key from Alpha Vantage" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                            <!-- Capital and Strategy Selection -->
                            <div class="flex items-center gap-2">
                                <label for="investment-amount" class="font-semibold text-gray-800 whitespace-nowrap">Initial Capital ($):</label>
                                <input type="number" id="investment-amount" value="1000" min="1" step="1" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="strategy-select" class="font-semibold text-gray-800 whitespace-nowrap">Strategy:</label>
                                <select id="strategy-select" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                                    <option value="custom">Custom (Manual Settings)</option>
                                    <option value="bollinger">Bollinger Band Swing</option>
                                    <option value="golden_cross">Golden Cross Filter (50/200)</option>
                                    <option value="rsi_sma">RSI + SMA Combo</option>
                                </select>
                            </div>
                        </div>
                        <!-- Strategy Explanations -->
                        <div id="strategy-explanation-container" class="mt-4 hidden">
                            <div id="bollinger-exp" class="hidden p-4 bg-blue-50 border-l-4 border-blue-400 text-sm">
                                <p class="font-bold">Bollinger Band Swing Strategy</p>
                                <p class="mt-1"><strong class="text-green-600">Buy Signal:</strong> Triggers a buy when the price touches or crosses <strong class="font-semibold">below the lower Bollinger Band</strong>, suggesting the asset is oversold.</p>
                                <p class="mt-1"><strong class="text-red-600">Sell Signal:</strong> Triggers a sell when the price touches or crosses <strong class="font-semibold">above the upper Bollinger Band</strong>, suggesting the asset is overbought.</p>
                            </div>
                            <div id="golden_cross-exp" class="hidden p-4 bg-blue-50 border-l-4 border-blue-400 text-sm">
                                <p class="font-bold">Golden Cross Filter (50/200 SMA)</p>
                                <p class="mt-1"><strong class="text-green-600">Buy Signal:</strong> This is a trend filter. A buy is only permitted if the <strong class="font-semibold">50-day SMA is above the 200-day SMA</strong>, indicating a long-term uptrend. The actual buy occurs on any day this condition is met.</p>
                                <p class="mt-1"><strong class="text-red-600">Sell Signal:</strong> Uses the default sell logic (sells on the next available day if profitable, or if "Sell on Loss" is checked). This strategy only filters for entry conditions.</p>
                            </div>
                            <div id="rsi_sma-exp" class="hidden p-4 bg-blue-50 border-l-4 border-blue-400 text-sm">
                                <p class="font-bold">RSI + SMA Combo Strategy</p>
                                <p class="mt-1"><strong class="text-green-600">Buy Signal:</strong> A two-part confirmation. A buy is triggered only if (1) the price is <strong class="font-semibold">above the 50-day SMA</strong> (confirming an uptrend) AND (2) the 14-day RSI is <strong class="font-semibold">below 30</strong> (indicating a short-term oversold condition).</p>
                                <p class="mt-1"><strong class="text-red-600">Sell Signal:</strong> Uses the default sell logic. This strategy focuses on finding strong, confirmed entry points within an established uptrend.</p>
                            </div>
                        </div>
                        <!-- Manual/Custom Controls -->
                        <div id="custom-controls" class="mt-4 space-y-4">
                            <div class="flex items-center justify-start sm:justify-end gap-x-4 gap-y-2 flex-wrap">
                                <div class="flex items-center gap-2 flex-wrap">
                                    <input type="checkbox" id="smart-entry-checkbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="smart-entry-checkbox" class="font-semibold text-gray-800 whitespace-nowrap">Smart Entry</label>
                                    <label for="sma-period-input" class="text-sm">SMA:</label>
                                    <input type="number" id="sma-period-input" value="50" min="2" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-20">
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="sell-on-loss-checkbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="sell-on-loss-checkbox" class="font-semibold text-gray-800 whitespace-nowrap">Sell on Loss</label>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="compounding-checkbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="compounding-checkbox" class="font-semibold text-gray-800 whitespace-nowrap">Compounding</label>
                                </div>
                            </div>
                        </div>
                        <!-- Date and Time Inputs -->
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-3">
                            <div class="flex items-center gap-2">
                                <label for="start-date" class="font-semibold text-gray-800">From:</label>
                                <input type="date" id="start-date" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="end-date" class="font-semibold text-gray-800">To:</label>
                                <input type="date" id="end-date" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="buy-time" class="font-semibold text-gray-800">Buy Time:</label>
                                <input type="time" id="buy-time" value="15:59" min="09:30" max="16:00" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="sell-time" class="font-semibold text-gray-800">Sell Time:</label>
                                <input type="time" id="sell-time" value="09:31" min="09:30" max="16:00" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2 w-full">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 self-end">
                    <button id="clear-cache-button" class="w-full sm:w-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 mt-4 sm:mt-0">
                        Clear Cache
                    </button>
                    <button id="reset-button" class="w-full sm:w-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 mt-4 sm:mt-0">
                        Reset
                    </button>
                    <button id="run-button" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 mt-4 sm:mt-0 disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Run Simulation
                    </button>
                </div>
            </div>

            <!-- Error Message -->
            <div id="error-message" class="hidden mt-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md" role="alert"></div>

            <!-- Results -->
            <div id="results-container" class="mt-6 hidden">
                <!-- Loader -->
                <div id="loader" class="flex flex-col justify-center items-center py-10">
                    <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24"></div>
                    <p id="loader-text" class="mt-4 text-gray-600">Fetching historical data...</p>
                </div>
                
                <!-- Summary -->
                <div id="summary" class="hidden">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Simulation Results</h2>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4 text-center">
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Initial Capital</p><p id="initial-capital" class="text-xl font-semibold text-gray-700"></p></div>
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Final Capital</p><p id="final-capital" class="text-xl font-semibold"></p></div>
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Total Return</p><p id="total-return" class="text-xl font-semibold"></p></div>
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Win Rate</p><p id="win-rate" class="text-xl font-semibold text-gray-700"></p></div>
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Completed Trades</p><p id="total-trades" class="text-xl font-semibold text-gray-700"></p></div>
                        <div class="bg-gray-50 p-4 rounded-lg"><p class="text-sm text-gray-500">Avg. Hold Period</p><p id="avg-hold-period" class="text-xl font-semibold text-gray-700"></p></div>
                    </div>
                </div>

                <!-- Trade Log -->
                <div id="trade-log-container" class="hidden mt-8">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">Trade Log</h3>
                    <div class="overflow-x-auto bg-white rounded-lg shadow">
                        <table class="min-w-full leading-normal">
                            <thead id="trade-log-head"></thead>
                            <tbody id="trade-log-body" class="text-sm"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Disclaimer: This is a financial simulation for educational purposes only. It does not constitute investment advice.</p>
            <p class="mt-1">Note: Free Alpha Vantage API keys limit calls to 25 per day. Fetched data is cached in your browser to minimize calls.</p>
        </footer>
    </div>

    <script>
        // --- Page Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set default dates
            document.getElementById('start-date').value = '2022-01-01';
            document.getElementById('end-date').value = '2023-12-31';
            
            const strategySelect = document.getElementById('strategy-select');
            const customControls = document.getElementById('custom-controls');
            const explanationContainer = document.getElementById('strategy-explanation-container');
            const explanations = {
                bollinger: document.getElementById('bollinger-exp'),
                golden_cross: document.getElementById('golden_cross-exp'),
                rsi_sma: document.getElementById('rsi_sma-exp')
            };

            strategySelect.addEventListener('change', () => {
                const selectedStrategy = strategySelect.value;
                
                // Hide or show the custom controls panel
                customControls.style.display = selectedStrategy === 'custom' ? 'block' : 'none';

                // Hide all explanations first
                explanationContainer.classList.add('hidden');
                Object.values(explanations).forEach(exp => exp.classList.add('hidden'));

                // Show the relevant explanation
                if (explanations[selectedStrategy]) {
                    explanationContainer.classList.remove('hidden');
                    explanations[selectedStrategy].classList.remove('hidden');
                }
            });

            // Trigger initial strategy selection
            strategySelect.dispatchEvent(new Event('change'));
        });

        // --- IndexedDB Caching ---
        const DB_NAME = 'tradingDataCache';
        const STORE_NAME = 'monthlyIntradayData';
        const CACHE_EXPIRY_DAYS = 30;

        function openDb() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject('Error opening IndexedDB: ' + event.target.errorCode);
            });
        }

        function getFromCache(db, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => {
                    const data = request.result;
                    if (data && data.timestamp) {
                        const ageDays = (Date.now() - data.timestamp) / (1000 * 60 * 60 * 24);
                        if (ageDays > CACHE_EXPIRY_DAYS) {
                            resolve(null); // Cache expired
                        } else {
                            resolve(data.data);
                        }
                    } else {
                        resolve(null);
                    }
                };
                request.onerror = () => reject('Error reading from cache');
            });
        }

        function saveToCache(db, key, data) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put({ data, timestamp: Date.now() }, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject('Error writing to cache');
            });
        }

        function clearCache() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => resolve();
                    clearRequest.onerror = () => reject('Error clearing cache');
                };
                request.onerror = () => reject('Error opening IndexedDB for clearing');
            });
        }

        // --- API & Data Fetching ---
        async function fetchMonthlyIntradayData(ticker, yearMonth, apiKey, retries = 3) {
            const url = `https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=${ticker}&interval=1min&month=${yearMonth}&outputsize=full&apikey=${apiKey}&datatype=csv`;
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`API request failed for ${yearMonth}: ${response.status}`);
                    }
                    const csvText = await response.text();
                    if (!csvText.startsWith('timestamp,open,high,low,close,volume')) {
                        const errorHint = csvText.includes("Our standard API call frequency is 25 calls per day") 
                            ? "API call limit reached. Try again tomorrow or use a premium API key."
                            : "Check ticker or API key validity.";
                        throw new Error(`Invalid intraday data from API for ${yearMonth}. ${errorHint}`);
                    }

                    const intradayData = {};
                    const rows = csvText.trim().split('\n').slice(1);
                    rows.forEach(row => {
                        const [timestamp, open, high, low, close, volume] = row.split(',');
                        if (timestamp && close && !isNaN(parseFloat(close))) {
                            intradayData[timestamp] = { close: parseFloat(close) };
                        }
                    });
                    return intradayData;
                } catch (err) {
                    if (attempt < retries) {
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        continue;
                    }
                    throw err;
                }
            }
        }

        // --- Indicator Calculation ---
        function calculateSMA(dailyPrices, period, cache = new Map()) {
            const cacheKey = `sma-${period}-${JSON.stringify(Object.keys(dailyPrices).sort())}`;
            if (cache.has(cacheKey)) return cache.get(cacheKey);

            const smaValues = {};
            const dates = Object.keys(dailyPrices).sort();
            for (let i = period - 1; i < dates.length; i++) {
                const currentSlice = dates.slice(i - period + 1, i + 1);
                const sum = currentSlice.reduce((acc, date) => acc + dailyPrices[date], 0);
                smaValues[dates[i]] = sum / period;
            }
            cache.set(cacheKey, smaValues);
            return smaValues;
        }

        function calculateRSI(dailyPrices, period, cache = new Map()) {
            const cacheKey = `rsi-${period}-${JSON.stringify(Object.keys(dailyPrices).sort())}`;
            if (cache.has(cacheKey)) return cache.get(cacheKey);

            const rsiValues = {};
            const dates = Object.keys(dailyPrices).sort();
            if (dates.length <= period) return {};

            let avgGain = 0;
            let avgLoss = 0;

            for (let i = 1; i <= period; i++) {
                const change = dailyPrices[dates[i]] - dailyPrices[dates[i - 1]];
                if (change > 0) avgGain += change;
                else avgLoss -= change;
            }
            avgGain /= period;
            avgLoss /= period;

            let rs = avgLoss !== 0 ? avgGain / avgLoss : 100;
            rsiValues[dates[period]] = 100 - (100 / (1 + rs));

            for (let i = period + 1; i < dates.length; i++) {
                const change = dailyPrices[dates[i]] - dailyPrices[dates[i - 1]];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? -change : 0;

                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;

                rs = avgLoss !== 0 ? avgGain / avgLoss : 100;
                rsiValues[dates[i]] = 100 - (100 / (1 + rs));
            }
            cache.set(cacheKey, rsiValues);
            return rsiValues;
        }

        function calculateBollingerBands(dailyPrices, period = 20, stdDev = 2, cache = new Map()) {
            const cacheKey = `bollinger-${period}-${stdDev}-${JSON.stringify(Object.keys(dailyPrices).sort())}`;
            if (cache.has(cacheKey)) return cache.get(cacheKey);

            const sma = calculateSMA(dailyPrices, period, cache);
            const dates = Object.keys(sma);
            const bands = { upper: {}, middle: sma, lower: {} };
            const sortedPriceDates = Object.keys(dailyPrices).sort();

            dates.forEach(date => {
                const dateIndex = sortedPriceDates.indexOf(date);
                if (dateIndex >= period - 1) {
                    const slice = sortedPriceDates.slice(dateIndex - period + 1, dateIndex + 1);
                    const pricesInSlice = slice.map(d => dailyPrices[d]);
                    const mean = sma[date];
                    const variance = pricesInSlice.reduce((acc, price) => acc + Math.pow(price - mean, 2), 0) / period;
                    const deviation = Math.sqrt(variance);
                    bands.upper[date] = mean + (stdDev * deviation);
                    bands.lower[date] = mean - (stdDev * deviation);
                }
            });
            cache.set(cacheKey, bands);
            return bands;
        }

        // --- Backtesting & Display ---
        function runBacktest(params) {
            const {
                intradayData, initialCapital, startDate, endDate, buyTime, sellTime, 
                useCompounding, sellOnLoss, strategy, smaPeriod
            } = params;

            const trades = [];
            let currentCapital = initialCapital;
            const uniqueDates = [...new Set(Object.keys(intradayData).map(ts => ts.split(' ')[0]))].sort();
            
            let heldPosition = null;
            const indicatorCache = new Map();

            // Prepare daily close prices
            const dailyClosePrices = {};
            uniqueDates.forEach(date => {
                const timestamp = `${date} ${buyTime}:00`;
                if (intradayData[timestamp]) {
                    dailyClosePrices[date] = intradayData[timestamp].close;
                }
            });

            let sma50, sma200, rsi14, bBands;

            if (strategy === 'golden_cross') {
                sma50 = calculateSMA(dailyClosePrices, 50, indicatorCache);
                sma200 = calculateSMA(dailyClosePrices, 200, indicatorCache);
            } else if (strategy === 'rsi_sma') {
                sma50 = calculateSMA(dailyClosePrices, 50, indicatorCache);
                rsi14 = calculateRSI(dailyClosePrices, 14, indicatorCache);
            } else if (strategy === 'bollinger') {
                bBands = calculateBollingerBands(dailyClosePrices, 20, 2, indicatorCache);
            } else if (strategy === 'custom' && params.useSmartEntry) {
                sma50 = calculateSMA(dailyClosePrices, smaPeriod, indicatorCache);
            }

            for (const currentDate of uniqueDates) {
                if (currentDate < startDate || currentDate > endDate) continue;

                const buyTimestamp = `${currentDate} ${buyTime}:00`;
                const sellTimestamp = `${currentDate} ${sellTime}:00`;
                const buyPrice = intradayData[buyTimestamp]?.close;
                const sellPrice = intradayData[sellTimestamp]?.close;

                // Skip if no data for buy or sell
                if (!buyPrice && !sellPrice) continue;

                // SELL LOGIC
                if (heldPosition && sellPrice) {
                    let sellSignal = false;
                    if (strategy === 'bollinger') {
                        if (bBands.upper[currentDate] && sellPrice >= bBands.upper[currentDate]) {
                            sellSignal = true;
                        }
                    } else {
                        const isProfitable = sellPrice > heldPosition.buyPrice;
                        if (isProfitable || sellOnLoss) {
                            sellSignal = true;
                        }
                    }

                    if (sellSignal) {
                        const profit = (sellPrice - heldPosition.buyPrice) * heldPosition.shares;
                        const buyDateObj = new Date(heldPosition.buyTimestamp);
                        const sellDateObj = new Date(sellTimestamp);
                        const hoursHeld = (sellDateObj - buyDateObj) / (1000 * 60 * 60);
                        const daysHeld = hoursHeld < 24 ? 0 : Math.round(hoursHeld / 24);

                        trades.push({
                            buyTimestamp: heldPosition.buyTimestamp,
                            buyPrice: heldPosition.buyPrice,
                            sellTimestamp,
                            sellPrice,
                            profit,
                            capitalBefore: heldPosition.capitalBeforeTrade,
                            capitalAfter: currentCapital + profit,
                            daysHeld
                        });
                        currentCapital += profit;
                        heldPosition = null;
                    }
                }

                // BUY LOGIC
                if (!heldPosition && buyPrice) {
                    let buySignal = false;
                    switch (strategy) {
                        case 'bollinger':
                            if (bBands.lower[currentDate] && buyPrice <= bBands.lower[currentDate]) {
                                buySignal = true;
                            }
                            break;
                        case 'golden_cross':
                            if (sma50[currentDate] && sma200[currentDate] && sma50[currentDate] > sma200[currentDate]) {
                                buySignal = true;
                            }
                            break;
                        case 'rsi_sma':
                            if (sma50[currentDate] && rsi14[currentDate] && buyPrice > sma50[currentDate] && rsi14[currentDate] < 30) {
                                buySignal = true;
                            }
                            break;
                        case 'custom':
                            if (params.useSmartEntry) {
                                if (sma50[currentDate] && buyPrice > sma50[currentDate]) {
                                    buySignal = true;
                                }
                            } else {
                                buySignal = true;
                            }
                            break;
                    }

                    if (buySignal) {
                        const investment = useCompounding ? currentCapital : initialCapital;
                        heldPosition = {
                            buyTimestamp,
                            buyPrice,
                            shares: Math.floor(investment / buyPrice), // Use whole shares
                            capitalBeforeTrade: currentCapital
                        };
                    }
                }
            }

            return { trades, finalCapital: currentCapital };
        }

        function displayResults(results, initialCapital) {
            const { trades, finalCapital } = results;
            const totalReturn = initialCapital !== 0 ? ((finalCapital - initialCapital) / initialCapital * 100) : 0;
            const totalTrades = trades.length;
            const winningTrades = trades.filter(t => t.profit > 0).length;
            const winRate = totalTrades > 0 ? (winningTrades / totalTrades * 100).toFixed(1) : '0.0';
            const totalDaysHeld = trades.reduce((sum, trade) => sum + trade.daysHeld, 0);
            const avgHoldPeriod = totalTrades > 0 ? (totalDaysHeld / totalTrades).toFixed(1) : '0.0';

            document.getElementById('initial-capital').textContent = `$${initialCapital.toFixed(2)}`;
            document.getElementById('final-capital').textContent = `$${finalCapital.toFixed(2)}`;
            document.getElementById('final-capital').className = `text-xl font-semibold ${finalCapital >= initialCapital ? 'text-green-600' : 'text-red-600'}`;
            document.getElementById('total-return').textContent = `${totalReturn.toFixed(2)}%`;
            document.getElementById('total-return').className = `text-xl font-semibold ${totalReturn >= 0 ? 'text-green-600' : 'text-red-600'}`;
            document.getElementById('win-rate').textContent = `${winRate}%`;
            document.getElementById('total-trades').textContent = totalTrades;
            document.getElementById('avg-hold-period').textContent = `${avgHoldPeriod} days`;

            const tradeLogHead = document.getElementById('trade-log-head');
            const tradeLogBody = document.getElementById('trade-log-body');
            tradeLogBody.innerHTML = '';

            tradeLogHead.innerHTML = `
                <tr class="border-b-2 border-gray-200 bg-gray-50 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">
                    <th class="px-5 py-3">Buy Time</th><th class="px-5 py-3">Buy Price</th>
                    <th class="px-5 py-3">Sell Time</th><th class="px-5 py-3">Sell Price</th>
                    <th class="px-5 py-3">Days Held</th>
                    <th class="px-5 py-3">P/L ($)</th><th class="px-5 py-3">Capital After</th>
                </tr>`;
            trades.forEach((trade) => {
                const profitClass = trade.profit >= 0 ? 'text-green-600' : 'text-red-600';
                const row = `
                    <tr class="border-b border-gray-200 hover:bg-gray-50">
                        <td class="px-5 py-4">${trade.buyTimestamp}</td>
                        <td class="px-5 py-4">$${trade.buyPrice.toFixed(2)}</td>
                        <td class="px-5 py-4">${trade.sellTimestamp}</td>
                        <td class="px-5 py-4">$${trade.sellPrice.toFixed(2)}</td>
                        <td class="px-5 py-4">${trade.daysHeld}</td>
                        <td class="px-5 py-4 ${profitClass} font-medium">$${trade.profit.toFixed(2)}</td>
                        <td class="px-5 py-4">$${trade.capitalAfter.toFixed(2)}</td>
                    </tr>`;
                tradeLogBody.innerHTML += row;
            });
        }

        // --- Input Validation ---
        function validateInputs(params) {
            const { ticker, apiKey, investmentAmount, startDate, endDate, buyTime, sellTime, strategy, smaPeriod, useSmartEntry } = params;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (!ticker || !/^[A-Z0-9.]+$/.test(ticker)) throw new Error("Please enter a valid ticker symbol (e.g., SPY, QQQ).");
            if (!apiKey) throw new Error("Please enter a valid Alpha Vantage API key.");
            if (isNaN(investmentAmount) || investmentAmount <= 0) throw new Error("Please enter a valid investment amount greater than 0.");
            if (!startDate || !endDate) throw new Error("Please select valid start and end dates.");
            if (new Date(startDate) >= new Date(endDate)) throw new Error("The 'From' date must be before the 'To' date.");
            if (new Date(startDate) > today || new Date(endDate) > today) throw new Error("Dates cannot be in the future.");
            if (strategy === 'golden_cross') {
                const minStartDate = new Date(endDate);
                minStartDate.setDate(minStartDate.getDate() - 200);
                if (new Date(startDate) > minStartDate) throw new Error("Golden Cross strategy requires at least 200 days of data before the end date.");
            }
            if (!buyTime || !sellTime) throw new Error("Please select valid buy and sell times.");
            const buyTimeParts = buyTime.split(':').map(Number);
            const sellTimeParts = sellTime.split(':').map(Number);
            if (buyTimeParts[0] < 9 || (buyTimeParts[0] === 9 && buyTimeParts[1] < 30) || buyTimeParts[0] > 16) {
                throw new Error("Buy time must be between 09:30 and 16:00.");
            }
            if (sellTimeParts[0] < 9 || (sellTimeParts[0] === 9 && sellTimeParts[1] < 30) || sellTimeParts[0] > 16) {
                throw new Error("Sell time must be between 09:30 and 16:00.");
            }
            if (strategy === 'custom' && useSmartEntry && (isNaN(smaPeriod) || smaPeriod < 2)) {
                throw new Error("Please enter a valid SMA period (>= 2).");
            }
        }

        // --- Main App Logic ---
        async function runSimulation() {
            const runButton = document.getElementById('run-button');
            const resetButton = document.getElementById('reset-button');
            const clearCacheButton = document.getElementById('clear-cache-button');
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loader-text');
            const resultsContainer = document.getElementById('results-container');
            const summary = document.getElementById('summary');
            const tradeLogContainer = document.getElementById('trade-log-container');
            const errorMessage = document.getElementById('error-message');
            const inputs = document.querySelectorAll('input, select');

            // Disable inputs and buttons
            runButton.disabled = true;
            resetButton.disabled = true;
            clearCacheButton.disabled = true;
            inputs.forEach(input => input.disabled = true);

            errorMessage.classList.add('hidden');
            resultsContainer.classList.remove('hidden');
            summary.classList.add('hidden');
            tradeLogContainer.classList.add('hidden');
            loader.style.display = 'flex';
            const onProgress = (msg) => loaderText.textContent = msg;
            onProgress('Preparing simulation...');

            try {
                // Get and validate parameters
                const params = {
                    ticker: document.getElementById('ticker-input').value.toUpperCase().trim(),
                    apiKey: document.getElementById('api-key').value.trim(),
                    investmentAmount: parseFloat(document.getElementById('investment-amount').value),
                    startDate: document.getElementById('start-date').value,
                    endDate: document.getElementById('end-date').value,
                    buyTime: document.getElementById('buy-time').value,
                    sellTime: document.getElementById('sell-time').value,
                    useCompounding: document.getElementById('compounding-checkbox').checked,
                    sellOnLoss: document.getElementById('sell-on-loss-checkbox').checked,
                    strategy: document.getElementById('strategy-select').value,
                    useSmartEntry: document.getElementById('smart-entry-checkbox').checked,
                    smaPeriod: parseInt(document.getElementById('sma-period-input').value, 10)
                };

                validateInputs(params);

                // Data aggregation
                const db = await openDb();
                const allIntradayData = {};
                const monthsToFetch = new Set();
                let currentDate = new Date(params.startDate);
                while (currentDate <= new Date(params.endDate)) {
                    const year = currentDate.getUTCFullYear();
                    const month = (currentDate.getUTCMonth() + 1).toString().padStart(2, '0');
                    monthsToFetch.add(`${year}-${month}`);
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }

                const totalMonths = monthsToFetch.size;
                let fetchedMonths = 0;

                for (const yearMonth of monthsToFetch) {
                    const cacheKey = `${params.ticker}-${yearMonth}`;
                    onProgress(`Checking cache for ${params.ticker} (${yearMonth})... (${Math.round((fetchedMonths / totalMonths) * 100)}%)`);
                    let monthData = await getFromCache(db, cacheKey);

                    if (monthData) {
                        onProgress(`Loaded ${params.ticker} (${yearMonth}) from cache. (${Math.round((fetchedMonths / totalMonths) * 100)}%)`);
                    } else {
                        onProgress(`Fetching data for ${params.ticker} (${yearMonth}) from API... (${Math.round((fetchedMonths / totalMonths) * 100)}%)`);
                        monthData = await fetchMonthlyIntradayData(params.ticker, yearMonth, params.apiKey);
                        await saveToCache(db, cacheKey, monthData);
                        onProgress(`Cached data for ${params.ticker} (${yearMonth}). (${Math.round((fetchedMonths / totalMonths) * 100)}%)`);
                    }
                    Object.assign(allIntradayData, monthData);
                    fetchedMonths++;
                }

                if (Object.keys(allIntradayData).length === 0) {
                    throw new Error("No intraday data available for the selected range. Check ticker or date range.");
                }

                params.intradayData = allIntradayData;

                // Run backtest
                onProgress('Running backtest...');
                const backtestResults = runBacktest(params);

                // Display results
                displayResults(backtestResults, params.investmentAmount);
                summary.classList.remove('hidden');
                tradeLogContainer.classList.remove('hidden');

            } catch (err) {
                errorMessage.textContent = err.message || 'An unexpected error occurred.';
                errorMessage.classList.remove('hidden');
            } finally {
                loader.style.display = 'none';
                runButton.disabled = false;
                resetButton.disabled = false;
                clearCacheButton.disabled = false;
                inputs.forEach(input => input.disabled = false);
            }
        }

        // Reset inputs to default
        function resetInputs() {
            document.getElementById('ticker-input').value = 'SPY';
            document.getElementById('api-key').value = 'PF9NLS6UHJ5VH89X';
            document.getElementById('investment-amount').value = '1000';
            document.getElementById('strategy-select').value = 'custom';
            document.getElementById('start-date').value = '2022-01-01';
            document.getElementById('end-date').value = '2023-12-31';
            document.getElementById('buy-time').value = '15:59';
            document.getElementById('sell-time').value = '09:31';
            document.getElementById('smart-entry-checkbox').checked = false;
            document.getElementById('sell-on-loss-checkbox').checked = false;
            document.getElementById('compounding-checkbox').checked = false;
            document.getElementById('sma-period-input').value = '50';
            document.getElementById('strategy-select').dispatchEvent(new Event('change'));
            document.getElementById('error-message').classList.add('hidden');
            document.getElementById('results-container').classList.add('hidden');
        }

        // Event listeners
        document.getElementById('run-button').addEventListener('click', runSimulation);
        document.getElementById('reset-button').addEventListener('click', resetInputs);
        document.getElementById('clear-cache-button').addEventListener('click', async () => {
            const clearCacheButton = document.getElementById('clear-cache-button');
            const errorMessage = document.getElementById('error-message');
            clearCacheButton.disabled = true;
            try {
                await clearCache();
                errorMessage.textContent = 'Cache cleared successfully.';
                errorMessage.className = 'mt-4 bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded-md';
                errorMessage.classList.remove('hidden');
            } catch (err) {
                errorMessage.textContent = 'Failed to clear cache: ' + err.message;
                errorMessage.className = 'mt-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md';
                errorMessage.classList.remove('hidden');
            } finally {
                clearCacheButton.disabled = false;
            }
        });
    </script>
</body>
</html>